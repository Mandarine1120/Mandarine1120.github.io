(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{381:function(t,e,n){"use strict";n.r(e);var o=n(4),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"textgcn-graph-convolutional-networks-for-text-classification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#textgcn-graph-convolutional-networks-for-text-classification"}},[t._v("#")]),t._v(" TextGCN：Graph Convolutional Networks for Text Classification")]),t._v(" "),n("ClientOnly",[n("title-pv")],1),t._v(" "),n("p",[t._v("论文将图卷积神经网络GCN用于文本分类任务，构造网络模型Text GCN，并在4个长文本数据集（20NG，R8,R52,Ohsumed）和1个短文本数据集(MR,电影短评论数据集)上进行了实验验证。")]),t._v(" "),n("p",[t._v("首先，论文构建了一个大型的异构文本图网络，图中包含单词节点和文档节点，以至于全局共现词可以被明确的构建出。如下图所示，文本图网络中的节点的数量为文档节点个数（数据集的大小）加上数据集中包含的不重复单词的个数（词汇表的大小）。")]),t._v(" "),n("p",[t._v("之后，论文在GCN基础上进行的改造，主要改造在于提出使用整个语料库构造成一个图，图中的节点是语料库中的每个document 和字典中所有的word，构建一个大图，并用邻接矩阵表示。构建好图及其邻接矩阵之后，使用GCN进行传递计算。")]),t._v(" "),n("p",[t._v("最后，文章使用两层GCN进行模型训练，并通过实验证明两层GCN比单层的或者两层以上GCN效果更好。最后作者在文章中对网络参数的选择进行了实验对比，也对模型的词向量学习进行了可视化表现，在多方面证明了GCN在文档分类上的有效性。这说明GCN中的图及其邻接矩阵可以用多种方式进行构建，比如词之间的相关程度，词与文档的相关程度，甚至是依赖树等任何你能想到的方式，所以提出新的图构建方式也是GCN在文档分类上的一种创新。")]),t._v(" "),n("ClientOnly",[n("leave")],1)],1)}),[],!1,null,null,null);e.default=a.exports}}]);